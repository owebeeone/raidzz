
		    Multiple redundancy RAID ....
					    Gianni Mariani

Background:

A common practice in data storage and transmission is to provide
redundancy in the stored or transmitted data so that the recipient of
the data can validate the correctness and in some circumstances correct
corrupted data.

A special instance of this is used in RAID (Redundant Array of
Inexpensive Disk) where one disk is used redundantly so that if the
data in one disk fails, the redundant disk can be used to recover the
data.  However, the only technology used today will allow a maximum of
only one redundant disk.  Many users will have multiple redundant disks
but only one disk will be allowed to fail.  This invention will allow
uses to have multiple redundant disks and hence be able to increase the
safety of their data by orders of magnitute without any significant
costs.

Theory:

The current redundantcy technology consists of a simple mathematical
equation:

The "+" operator is a logical exclusive or (XOR).

    S = d0 + d1 + ... + dn .			    dn = 0,1.

Hence, in the loss of any element ( dc for example ) it can be recovered
using the following equation.

    dx = S + d0 + d1 ... dc-1 + dc+1 .... + dn .

A more general form of this equation and one generally unknown is :
The "+" operator here is a bitwise exclusive or (XOR).

    Sa = fa0(d0) + fa1(d1) + fa2(d2) + ... + fan(dn)
    Sb = fb0(d0) + fb1(d1) + fb2(d2) + ... + fbn(dn)
     ....
    Sx = fx0(d0) + fx1(d1) + fx2(d2) + ... + fxn(dn)

							dn = 0 ... (2^z)-1
							 z = 2 ... n

The difficulty is to find suitable fxn() functions since they must
beet the following conditions:

    a) fxn functions need to be invertable i.e. there must exist
       an Ifxn i.e.:

	Ifxn( fxn( d ) ) = d	    for all d (as dn above)

    b) The combinations of fxn() must be unique.

	The set
	    ( fal( dl ) + fam( dm ),
	      fbl( dl ) + fbm( dm ),
	      ...
	      fxl( dl ) + fxm( dm )
	    )

	for m != l must be unique for all l,m,dl,dm.

Recovery of data is given by creating inverse functions wich is made
possible by the conditions a and b above.

In the loss of one disk, any one of the redundant disks can be used
to recover data using this equation.

    dc = Ifc( Sx + fax(d0) + ... fxc-1(dc-1) + fac-1(dc+1)... + fxn(dn) )

In the case for recovery of two disks the the contruction of an inverse
function (IFlm) needs to be created i.e.:

    IFxy_lm( fxl( dl ) + fxm( dm ), fyl( dl ) + fym( dm ) ) = ( dl, dm )

This is made possible by condition b above.  The input to this function
is easily computed by:

				 ___
				 \
    fxl( dl ) + fxm( dm ) = Sx + /  faq(dq)
				 ---
				q != l
				q != m
				q = 0..n

Here is an example set of functions for z = 2 .

    fa0 = { 3, 0, 1, 2 }
    fa1 = { 2, 1, 0, 3 }
    fb0 = { 2, 0, 3, 1 }
    fb1 = { 1, 2, 3, 0 }

In general these functions are difficult to compute for z > 3;

The tables below are for fb0 to fb15.  The faN functions are
the same as fb0 for all N.

fa0 = fa1 = fa2 .... = fa15 = fb0 =
    { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
	0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, }

fb1 = { 0x02, 0x03, 0x01, 0x08, 0x0a, 0x0b, 0x09, 0x0c,
	0x0e, 0x0f, 0x0d, 0x04, 0x06, 0x07, 0x05, 0x00, }
fb2 = { 0x03, 0x01, 0x02, 0x0c, 0x0f, 0x0d, 0x0e, 0x04,
	0x07, 0x05, 0x06, 0x08, 0x0b, 0x09, 0x0a, 0x00, }
fb3 = { 0x04, 0x08, 0x0c, 0x06, 0x02, 0x0e, 0x0a, 0x0b,
	0x0f, 0x03, 0x07, 0x0d, 0x09, 0x05, 0x01, 0x00, }
fb4 = { 0x05, 0x0a, 0x0f, 0x02, 0x07, 0x08, 0x0d, 0x03,
	0x06, 0x09, 0x0c, 0x01, 0x04, 0x0b, 0x0e, 0x00, }
fb5 = { 0x06, 0x0b, 0x0d, 0x0e, 0x08, 0x05, 0x03, 0x07,
	0x01, 0x0c, 0x0a, 0x09, 0x0f, 0x02, 0x04, 0x00, }
fb6 = { 0x07, 0x09, 0x0e, 0x0a, 0x0d, 0x03, 0x04, 0x0f,
	0x08, 0x06, 0x01, 0x05, 0x02, 0x0c, 0x0b, 0x00, }
fb7 = { 0x08, 0x0c, 0x04, 0x0b, 0x03, 0x07, 0x0f, 0x0d,
	0x05, 0x01, 0x09, 0x06, 0x0e, 0x0a, 0x02, 0x00, }
fb8 = { 0x09, 0x0e, 0x07, 0x0f, 0x06, 0x01, 0x08, 0x05,
	0x0c, 0x0b, 0x02, 0x0a, 0x03, 0x04, 0x0d, 0x00, }
fb9 = { 0x0a, 0x0f, 0x05, 0x03, 0x09, 0x0c, 0x06, 0x01,
	0x0b, 0x0e, 0x04, 0x02, 0x08, 0x0d, 0x07, 0x00, }
fb10= { 0x0b, 0x0d, 0x06, 0x07, 0x0c, 0x0a, 0x01, 0x09,
	0x02, 0x04, 0x0f, 0x0e, 0x05, 0x03, 0x08, 0x00, }
fb11= { 0x0c, 0x04, 0x08, 0x0d, 0x01, 0x09, 0x05, 0x06,
	0x0a, 0x02, 0x0e, 0x0b, 0x07, 0x0f, 0x03, 0x00, }
fb12= { 0x0d, 0x06, 0x0b, 0x09, 0x04, 0x0f, 0x02, 0x0e,
	0x03, 0x08, 0x05, 0x07, 0x0a, 0x01, 0x0c, 0x00, }
fb13= { 0x0e, 0x07, 0x09, 0x05, 0x0b, 0x02, 0x0c, 0x0a,
	0x04, 0x0d, 0x03, 0x0f, 0x01, 0x08, 0x06, 0x00, }
fb14= { 0x0f, 0x05, 0x0a, 0x01, 0x0e, 0x04, 0x0b, 0x02,
	0x0d, 0x07, 0x08, 0x03, 0x0c, 0x06, 0x09, 0x00, }


